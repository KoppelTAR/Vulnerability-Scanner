const axios = require('axios');
const https = require('https');
const psl = require('psl');

const responseClass = require('../models/response')

const agent = new https.Agent({
    rejectUnauthorized: false
});

exports.getWebsite = async (req, res) => {
    try {
        const resp = await axios.get(req.query.url, {timeout: req.query.timeout, httpsAgent: agent});
        return res.status(resp.status).send(console.log(resp.status))
    } catch (error) {
        if (error.code == "ENOTFOUND") {
            return res.status(500).send(console.log("Something went wrong with the request."))
        } if (error.code == "ECONNABORTED") {
            return res.status(408).send(console.log("Request took too long."))
        } else {
            return res.status(error.response.status).send(console.log(error.response.status))
        }
    }
    
}

const standardRemedyText = "Restrict access to this "

exports.getPhpInfo = (req, res) => {
    multipleGetRequests(["/phpinfo.php","/test.php","/info.php","/phpinfo" ],"PHP Version","PHP info page exposure","Exposed PHP info page can give attackers information about software, system parameters and possible vulnerabilities affecting the website.",standardRemedyText+"page.",req,res)
}

exports.getWPConfig = (req, res) => {
    multipleGetRequests(["/wp-config.php.save","/wp-config.php~","/wp-config.php_orig","/wp-config.php.old","/wp-admin/admin-ajax.php?action=duplicator_download&file=%2F..%2Fwp-config.php" ],"The base configurations of the WordPress.","WordPress config exposure","Exposed WordPress config file can lead to attackers accessing sensitive information about the website's database and other vulnerabilities such as outdated plugins.",standardRemedyText+"file.",req,res)
}

exports.getErrorLog = (req, res) => {
    multipleGetRequests(["/error.log","/error_log.txt","/logs/errors.log","/error_log" ],"PHP Fatal error","Error log exposure","Exposed error logs can provide attackers with information about the server's file system directory and other vulnerabilities such as outdated plugins.",standardRemedyText+"file.",req,res)
}

exports.getPhpMyAdmin = (req, res) => {
    multipleGetRequests(["/phpmyadmin/setup/index.php","/phpmyadmin/scripts/setup.php","/pma/setup/index.php","/pma/scripts/setup.php" ],/\bphpMyAdmin\b[\s\S]*?\bconnection\b|\bconnection\b[\s\S]*?\bphpMyAdmin\b/,"PhpMyAdmin setup page exposure","Exposed PhpMyAdmin setup page can lead to attackers altering or damaging the websites database.",standardRemedyText+"page.",req,res)
}

exports.getSQLDump = (req, res) => {
    multipleGetRequests(["/dump.sql","/backup.sql","/sql.sql","/db_backup.sql","/db.sql","/database.sql",getDomainName(req.query.url,"full")+".sql" ],"TABLE","Database backup exposure","Exposed database dumps can lead to sensitive information being accessed by attackers.",standardRemedyText+"file.",req,res)
}

exports.getBackup = (req, res) => {
    multipleGetRequests([getDomainName(req.query.url,"full")+".zip",getDomainName(req.query.url,"name")+".tar.gz",getDomainName(req.query.url,"name")+".zip" ],"ï¿½","Website backup exposure","Exposed website backups can lead to attackers stealing the websites source code, receiving information about the website settings and security vulnerabilities and getting access to the websites database.",standardRemedyText+"file.",req,res)
}

exports.getGitConfig = (req, res) => {
    getRequest("/.git/config","core","Git config exposure","Exposed git config file can lead to attackers finding the remote repository housing the websites source code and stealing it.",standardRemedyText+"file.",req,res)
}

exports.getDockerCompose = (req, res) => {
    getRequest("/docker-compose.yml",/\bversion\b[\s\S]*?\bservices\b|\bservices\b[\s\S]*?\bversion\b/,"Docker compose config exposure","Exposed docker-compose config file can provide attackers with information about the software used, system parameters and possible vulnerabilities affecting the website.",standardRemedyText+"file.",req,res) 
}

exports.getLaravelLog = (req, res) => {
    getRequest("/storage/logs/laravel.log","laravel","Laravel log exposure","Exposed Laravel log file can provide attackers with information about the server's file system directory, system parameters, and vulnerabilities affecting the website.",standardRemedyText+"file.",req,res) 
}

exports.getWPDebugLog = (req, res) => {
    getRequest("/wp-content/debug.log",/\bwp\b[\s\S]*?\bon line\b|\bon line\b[\s\S]*?\bwp\b/,"WordPress debug log exposure","Exposed WordPress debug log file can provide attackers with information about the server's file system directory, system parameters, and vulnerabilities affecting the website.",standardRemedyText+"file.",req,res) 
}

exports.getApacheStatus = (req, res) => {
    getRequest("/server-status","Apache Status","Apache server status exposure","Exposed Apache server status can, depending on the configuration, leak various information about the given server itself, about the vhosts on it, the IPs of the clients and the location of the request.",standardRemedyText+"file.",req,res) 
}

exports.getSymfonyDatabaseConfig = (req, res) => {
    getRequest("/config/databases.yml","symfony","Symfony database config exposure","Exposed Symfony config file can leak the database credentials.",standardRemedyText+"file.",req,res) 
}

exports.getLocalFileInclusionGeneric = (req, res) => {
    getRequest("/etc/passwd","daemon","Local file inclusion","This vulnerability allows an attacker to request files from the server to which access is restricted.",standardRemedyText+"page.",req,res) 
}

exports.getLocalFileInclusionDuplicator = (req, res) => {
    getRequest("/wp-admin/admin-ajax.php?action=duplicator_download&file=..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd","daemon","Local file inclusion due to Duplicator","An outdated duplicator plugin allows an attacker to request files from the server to which access is restricted.","Update the Duplicator plugin for WordPress.",req,res) 
}

exports.getWPLogin = (req, res) => {
    getRequest("/wp-login.php","loginform","WordPress public login page","A public WordPress login page can be brute forced by an attacker to gain access to the admin panel.",standardRemedyText+"page.",req,res) 
}

exports.getJCKEditor = (req, res) => {
    getRequest('/plugins/editors/jckeditor/plugins/jtreelink/dialogs/links.php?extension=menu&parent="%20UNION%20SELECT%20NULL,NULL,CONCAT_WS(0x203a20,USER(),DATABASE(),VERSION()),NULL,NULL,NULL,NULL,NULL--%20aa&view=menu',"node","JCK Editor SQL injection","An outdated JCKEditor plugin can be used by an attacker to perform SQL injection attacks.","Update the JCK editor for Joomla!.",req,res) 
}

exports.getJoomlaConfig = (req, res) => {
    getRequest("/configuration.php-dist","Database configuration section","Joomla Config exposure","Exposed Joomla config file can provide attackers with information about the server's file system directory, system parameters, and vulnerabilities affecting the website.",standardRemedyText+"file.",req,res) 
}

async function getRequest(endpoint,regex,vulnerabilityName,vulnerabilityDescription,vulnerabilityRemedy,req,res) {
        try {
            if (typeof regex == "object") { 
                // A better solution could be achieved with a array to loop through every keyword but I have already spent way to much time on the current system that the end does not justify the means.
                regex = new RegExp(regex)
            }
            else {
                regex = new RegExp("\\W?"+regex+"\\W")
            }
            if (req.query.url.slice(-1) == "/") {
                endpoint = endpoint.substring(1);
            }
            const resp = await axios.get(req.query.url + endpoint, {signal: AbortSignal.timeout(parseInt(req.query.timeout)), httpsAgent: agent});
            if (resp.data.match(regex) && resp.status == 200 && resp.status != undefined) {
                return res.status(resp.status).send(new responseClass.Response(resp.status,"Vulnerability found.",resp.config.url,vulnerabilityName,vulnerabilityDescription,vulnerabilityRemedy))
            }
            else {
                return res.status(404).send(new responseClass.Response(404,"Not found",resp.config.url,vulnerabilityName,vulnerabilityDescription))
            }
        } catch (error) {
            if (error.code == "ERR_BAD_REQUEST") {
                return res.status(error.response.status).send(new responseClass.Response(error.response.status,error.response.statusText,error.config.url,vulnerabilityName,vulnerabilityDescription))
            } if (error.code == "ENOTFOUND" || error.code == "ECONNREFUSED" || error.code ==  "EPROTO") {
                return res.status(500).send(new responseClass.Response(500,"Website may not exist.",error.config.url,vulnerabilityName,vulnerabilityDescription)) 
            } if (error.code == "ECONNABORTED" || error.code ==  "ERR_CANCELED") {
                return res.status(408).send(new responseClass.Response(408,"Request took too long.",error.config.url,vulnerabilityName,vulnerabilityDescription))
            } if (error.response == undefined) {
                return res.send("Something went horribly wrong. Use console logs to debug.")
            }
             else {
                return res.status(error.response.status).send(new responseClass.Response(error.response.status,error.response.statusText,error.response.config.url,vulnerabilityName,vulnerabilityDescription))
            }
        }
}

function multipleGetRequests(endpoints,regex,vulnerabilityName,vulnerabilityDescription,vulnerabilityRemedy,req,res) {
    let requests = [];
    for (let index = 0; index < endpoints.length; index++) {
        let endpoint = endpoints[index];
        if (req.query.url.slice(-1) == "/") {
            endpoint = endpoint.substring(1);
        }
        requests.push(axios.get(req.query.url + endpoint, {signal: AbortSignal.timeout(parseInt(req.query.timeout)), httpsAgent: agent}))
    }
    Promise.allSettled(requests).then((results) => {
        if (typeof regex == "object") { 
            regex = new RegExp(regex)
        }
        else {
            regex = new RegExp("\\W?"+regex+"\\W")
        }
        for (let index = 0; index < results.length; index++) {
            const result = results[index];
            if (result.value != undefined && result.value.status == 200 && result.value.data.match(regex)) {
                return res.status(result.value.status).send(new responseClass.Response(result.value.status,"Vulnerability found.",result.value.config.url,vulnerabilityName,vulnerabilityDescription,vulnerabilityRemedy))
            }
             if (!results[index + 1] && result.status != "fulfilled") {
                if (result.reason.code == "ERR_BAD_REQUEST") {
                    return res.status(result.reason.response.status).send(new responseClass.Response(result.reason.response.status,result.reason.response.statusText,result.reason.config.url,vulnerabilityName,vulnerabilityDescription))
                } if (result.reason.code == "ENOTFOUND" || result.reason.code == "ECONNREFUSED" || result.reason.code == "EPROTO") {
                    return res.status(500).send(new responseClass.Response(500,"Website may not exist.",result.reason.config.url,vulnerabilityName,vulnerabilityDescription)) 
                } if (result.reason.code == "ECONNABORTED" || result.reason.code == "ERR_CANCELED") {
                    return res.status(408).send(new responseClass.Response(408,"Request took too long.",result.reason.config.url,vulnerabilityName,vulnerabilityDescription))
                } if (result.reason.response == undefined) {
                    return res.send("Something went horribly wrong. Use console logs to debug.")
                } else {
                    return res.status(result.reason.response.status).send(new responseClass.Response(result.reason.response.status,result.reason.response.statusText,result.reason.config.url,vulnerabilityName,vulnerabilityDescription))
                }
            }
            if (!results[index + 1] && result.status == "fulfilled") {
                return res.status(404).send(new responseClass.Response(404,"Not found",result.value.config.url,vulnerabilityName,vulnerabilityDescription))
            }
        }
      })
}

function getDomainName(domain,type) {
    String(domain)
    if (type == "full") {
        domain = domain.replace(/^https?:\/\//, '/')
        domain = domain.replace(/\/+$/, "");
        return domain
    }
    if (type == "name") {
        domain = domain.replace(/^https?:\/\//, '')
        domain = domain.replace(/\/+$/, "");
        return psl.parse(domain).sld
    }

}